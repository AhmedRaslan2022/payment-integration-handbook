# üß≠ Payment Gateway Integration Guide

This guide outlines the essential steps for integrating a **payment gateway**, focusing on secure, reliable, and real-time payment processing.  
It covers **Webhook (Callback URL) Registration**, **Payment Session Creation**, and **Webhook Event Handling & WebView Redirections**, along with best practices to ensure a robust implementation.

> ‚ö†Ô∏è Always review your gateway‚Äôs official documentation carefully, as request formats, signature headers, and field names can vary between providers.

---

## Webhook (Callback URL) Registration

The webhook endpoint allows the payment gateway to notify you whenever a transaction‚Äôs status changes (e.g., success, failure, refund).  
Your backend must handle these notifications securely and idempotently, updating your internal order state only after verifying authenticity.

###  Setup Methods

- **Dashboard-based registration**  
  Some gateways (e.g., **MyFatoorah**) allow webhook registration directly from their admin panel.

- **API-based registration**  
  Others (e.g., **Tabby**, **Tamara**) provide API endpoints for dynamic registration.

### Example (via cURL)

```bash
curl --request POST \
--url https://api.tabby.ai/api/v1/webhooks \
--header 'Authorization: Bearer <token>' \
--header 'Content-Type: application/json' \
--header 'X-Merchant-Code: <x-merchant-code>' \
--data '{
  "url": "https://example.com/api/v1/payments/webhook",
  "header": {
    "title": "Custom-Signature-Header",
    "value": "RandomStringOrSecret"
  }
}'

```
---

#  Session Creation Request

After webhook setup, your system creates a **payment session** to initialize the transaction.  
This API call prepares the order details and returns a secure **checkout URL** or **session token**, which redirects the user to the gateway‚Äôs payment page.

---

## üßæ Required Fields

Refer to your gateway‚Äôs documentation ‚Äî typical parameters include:

| Field | Description |
|--------|-------------|
| `order_reference` | Unique order ID generated by your system |
| `total_amount` | The total transaction amount |
| `currency` | The transaction currency (e.g., SAR, USD) |
| `customer` | Customer information (name, email, phone) |
| `items` | List of purchased products or services |
| `success_url` | Redirect URL after successful payment |
| `failure_url` | Redirect URL after failed payment |
| `cancel_url` | Redirect URL if the user cancels the payment |

> üí° **Note:**  
> If your business model doesn‚Äôt require certain fields (e.g., shipping for digital goods), clarify this with the payment provider:  
> ‚ÄúOur products are digital services and do not require a shipping address. Please confirm if this field can be omitted.‚Äù

---



#   Handle Webhooks (Callback URLs)

After a payment is initiated, you must handle both **asynchronous webhooks** (server-to-server) and **frontend redirections** (user-facing) to ensure payment confirmation and order-status consistency.

---

## üì® Webhook Events Handling

Webhooks notify your backend in real time about key payment events, such as:

| Event | Description |
|--------|-------------|
| `payment_success` | Payment completed successfully |
| `payment_failed` | Payment attempt failed |
| `payment_expired` | Payment session expired |
| `payment_captured` | Funds successfully captured |
| `refund_processed` | Refund issued to the customer |


On Receiving an Event:

1. Respond immediately with HTTP 200 OK ‚Äî This acknowledges receipt of the webhook to prevent retries.‚Ä®
-Handle processing asynchronously in the background to keep your endpoint fast and reliable.

2. Validate authenticity (HMAC/Signature Check) ‚Äî‚Ä®
The gateway signs each webhook payload using a shared secret key.‚Ä®Your server must re-generate this HMAC (Hash-based Message Authentication Code) from the payload and compare it to the received signature.‚Ä®
If both match, the webhook is confirmed as authentic and unaltered.‚Ä®This prevents spoofed or tampered requests.

3. Extract key identifiers ‚Äî order_id, transaction_id, status

4. Update your database or order record.

5. Log the raw payload and timestamp for auditing and debugging

---


# üåê  WebView Redirections 

This section focuses on handling frontend redirections after checkout, implementing backend best practices, managing installment-based capture flows, and adding resilience through a circuit breaker mechanism.

---

## üåê WebView Redirections

Some payment gateways (e.g., **Tamara**, **Tabby**) redirect users to specific URLs after they complete or cancel a payment.  
You must configure these redirect URLs in both your **gateway dashboard** and your **backend configuration**.

| URL Type | Description |
|-----------|--------------|
| `success_url` | Redirect after successful payment |
| `failure_url` | Redirect after payment failure |
| `cancel_url` | Redirect when user cancels or abandons payment before completion |

### üîÅ Flow

1. User completes payment ‚Üí Gateway redirects to `success_url`, `failure_url`, or `cancel_url`.  
2. Frontend displays an appropriate confirmation, error, or cancellation screen.  
3. Frontend calls your backend to **recheck payment status** from your database or via the **gateway‚Äôs Payment Details API**.  
4. Backend confirms the latest order status to the frontend for accurate display.

> ‚ö†Ô∏è **Important:** Never rely solely on redirection for payment confirmation.  
> Redirections are user-facing only ‚Äî always validate payment success through **webhooks** or a **Payment Details API call**.

---

# Handling Refunds
 
Refunds are a critical part of the payment lifecycle and must be handled securely, traceably, and consistently with your gateway‚Äôs capabilities.‚Ä®Most gateways support two refund methods ‚Äî API-based refunds (automated) and manual refunds (via their dashboard/admin panel).

üîÅ Refund Scenarios

| Type              | Description                                                                                                                    |
| ----------------- | ------------------------------------------------------------------------------------------------------------------------------ |
| **API Refund**    | The merchant‚Äôs backend triggers a refund request programmatically using the gateway‚Äôs Refund API.                              |
| **Manual Refund** | The refund is initiated manually through the gateway‚Äôs admin dashboard; the backend learns about it later via a webhook event. |

‚öôÔ∏è API-Based Refund Flow
When your system needs to trigger a refund (e.g., user cancels order or returns goods), always use the official Refund API provided by the payment gateway.

‚úÖ Recommended Flow
1. Identify the Transaction
    * Retrieve the original payment_id or transaction_id from your database (usually received during session creation or webhook).
    
2. Call the Refund API
    * Send a POST request to the gateway‚Äôs refund endpoint, typically including:
        * payment_id or transaction_id
        * refund_amount
        * reason or comment (optional)
        * reference_id (for your own internal tracking)
  
 Example
 {
    "payment_id": "abc123",
    "amount": 150.00,
    "currency": "SAR",
    "reason": "Customer cancellation",
    "reference": "ORD-1009"
  }


  Handle API Response
    * If the refund is accepted, record its refund_id, status (pending, processed, failed), and timestamp in your database.
    * Some gateways may perform refunds asynchronously, meaning success does not guarantee funds have been transferred ‚Äî rely on the webhook for final confirmation.
    
  Wait for Webhook Confirmation
    * Once the refund is completed, the gateway sends a refund_processed or refund_succeeded event to your webhook endpoint.
    * You should:
        * Validate the webhook signature (HMAC check).
        * Update the order‚Äôs refund status in your system.
        * Record the amount and timestamp for auditing.
        * Optionally notify the user via email or push notification.


## üí≥ Installment Gateways ‚Äî Capturing the Payment

Some Buy Now, Pay Later (BNPL) or installment gateways (e.g., **Tabby**, **Tamara**) use a **two-step payment process**:  
Authorization first, then capture.

| Stage | Description |
|--------|-------------|
| **Authorization** | Amount is reserved on the customer‚Äôs card (no funds transferred yet). |
| **Capture** | Merchant explicitly captures (all or part of) the authorized amount after successful checkout. |

### ‚öôÔ∏è Implementation Notes

- Always capture payments using the gateway‚Äôs **Capture API**.  
- Use the `payment_id` or `transaction_id` returned from session creation or webhook.  
- For **partial captures** (e.g., partial shipments or staged billing), specify the `amount` in the API call.  
- Log every capture attempt with timestamps for traceability.
---


## ‚öôÔ∏è Recommended Flow

Below is the general session-based payment flow that most gateways follow:

1. **User initiates payment**  
   ‚Üí You create a payment session via API  
   ‚Üí The user is redirected to the gateway‚Äôs checkout page.

2. **User completes payment**  
   ‚Üí The gateway redirects the user to one of the following URLs:  
   - `success_url`  
   - `failure_url`  
   - `cancel_url`

3. **Webhook fires**  
   ‚Üí The gateway sends a **server-to-server confirmation** to your registered webhook endpoint.  
   ‚Üí The backend must:
   - Respond **immediately** with `HTTP 200 OK`  
   - Validate the webhook signature (HMAC or secret key)  
   - Update the internal order state (e.g., Paid, Failed)

4. **Reconciliation / Fallback Process**  
   ‚Üí A scheduled background job (cron or queue worker) rechecks any orders still marked as ‚Äúpending.‚Äù  
   ‚Üí Calls the gateway‚Äôs **Payment Details Endpoint** to verify and correct their status if needed.

---

## ‚ö° Circuit Breaker for Live Systems

What is a Circuit Breaker?

A Circuit Breaker is a fault-tolerance mechanism that prevents your system from repeatedly calling a failing external service (like a payment gateway).
Once failures exceed a threshold, the "circuit" opens and stops further calls until the service recovers.

How It Works

1. Closed State:‚Ä®All requests flow normally. If failures exceed a threshold (timeouts, 5xx errors), the breaker opens.
2. Open State:‚Ä®Requests are temporarily blocked for a cooldown period (e.g., 30 seconds).
3. Half-Open State:‚Ä®The system sends test requests after cooldown ‚Äî if successful, it closes again; if not, it stays open longer.

Why Use It?
* Improves stability and user experience during gateway downtime.
* Enables graceful fallbacks (e.g., show ‚ÄúService is temporarily unavailable‚Äù instead of breaking checkout).

---

 ## üß† Best Practices

A strong payment integration balances security, reliability, and clarity in user experience.  
Follow these principles across all your gateway flows:

1. **Never trust frontend data**  
   - All sensitive logic (status updates, refunds, payment validation) must happen server-side.  
   - Frontend data can be manipulated using tools like *Proxyman* or *Charles Proxy*.

2. **Use idempotency**  
   - If a webhook or capture call repeats, ensure it‚Äôs processed only once using `event_id` or `transaction_id` checks.

3. **Acknowledge webhooks quickly**  
   - Always respond with `HTTP 200 OK` immediately, even if background work remains.

4. **Secure your endpoints**  
   - Enforce HTTPS, use shared secrets or signature headers, and validate HMACs on every request.

5. **Log everything**  
   - Store raw payloads, timestamps, and responses for reconciliation, debugging, and audits.
   - Visualize and debug webhook and API requests and responses using JSON Grid, a structured view that makes nested JSON data easier to read and inspect during development troubleshooting.

6. **Combine Webhooks + Payment Details API**  
   - Webhooks = Real-time confirmation  
   - Payment Details API = Fallback verification when webhooks fail or delay
---

  # üß† Q&A ‚Äî Handling Common Payment Integration Scenarios


## ‚ùì Q1: What should I do if the webhook request never reaches my server?

‚úÖ **Answer:**

1. **Check endpoint accessibility**  
   - Ensure your callback URL is publicly accessible (not behind VPN, local server, or firewall).

2. **Use HTTPS with a valid SSL certificate**  (if needed by the gateway requirements)
   - Payment gateways reject non-secure or invalid endpoints.

3. **Verify exact URL match**  
   - Confirm the callback URL matches what‚Äôs registered in the gateway dashboard (case-sensitive, trailing slashes matter).

4. **Inspect gateway logs or dashboard**  
   - Look for delivery attempts, response codes, and timestamps.

5. **Implement fallback reconciliation**  
   - Periodically call the **Payment Details API** to reconcile any orders still marked as ‚Äúpending‚Äù if webhook delivery fails.

---

## ‚ùì Q2: The webhook endpoint receives the event, but my system processes it multiple times. How can I prevent that?

‚úÖ **Answer: Implement Idempotency**

1. **Check for duplicate events**  
   - Before processing, verify if the `event_id` or `transaction_id` already exists in your database.

2. **Store processed events**  
   - Save the event or transaction ID in a dedicated table with a timestamp.

3. **Return `HTTP 200 OK` for duplicates**  
   - Always respond with 200, even if the event was already processed.  
     Gateways retry failed deliveries if a non-200 status is returned.

4. **Example Table: `webhook_events`**

   |  event_id | transaction_id |    processed_at      | 
   |-----------|----------------| -------------------- |
   |   12345   |   tx_98765     |  2025-11-02 13:22:44 |

---

## ‚ùì Q3: How do I verify webhook authenticity (HMAC signature)?

‚úÖ **Answer:**

1. **Retrieve the signature**
   - Extract the signature from the webhook‚Äôs request headers (e.g., `X-Signature` or `X-HMAC`).

2. **Recreate the HMAC hash locally**
   - Generate your own hash using the same algorithm (e.g., SHA256) and the secret key provided by the gateway.

---

 ## ‚ùì Q4: The user completed payment successfully but wasn‚Äôt redirected to success_url. What should I do?

‚úÖ Answer:

Always treat webhook events as the primary confirmation.

Even if redirection fails (e.g., user closes browser), your  will still receive the webhook.

Use your frontend to query the backend and display the order‚Äôs final status instead of depending solely on redirection.

---


## ‚ùì Q6: How can I safely handle refund or capture APIs?

‚úÖ Answer:

Always use the payment_id or transaction_id provided by the gateway.

Capture or refund only after webhook confirmation of success or authorization.

For partial captures or refunds, include the specific amount and record the action for audit purposes.

Maintain a capture log table containing payment_id, amount, timestamp, and user_id.
